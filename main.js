"use strict";



// Условие задачи
/*
const obj = {
  b: {
    c: 1
  }
};

И есть путь в виде строки

const path = 'b.c';

Необходимо написать функцию
const result = (obj, path) => {
  ...
}

Которая принимает объект и путь и возвращает значение последнего ключа в пути.
Для объекта obj и path в переменной result должно быть 1.
*/



// Итак, дано:
const obj = {
    b: {
      c: 1
    },
};
  
const path = 'b.c';




// 1 вариант решения
let arrPath = path.split(".");

const result = function (obj, arrPath) {

    // пришлось отказаться от идеи цикла через for... of, ибо
    // второй итерацией мы получим undefined.
    // Как раз об этом Вы спрашивали на собеседовании, но я не уловил суть вопроса, думал о другом.
    // Ставлю ограничение "i", чтобы мы получили только первый элемент массива
    for (let i = 0; i < 1; i++) {

        // и еще одно решение, о котором Вы намекали - введение новой переменной
        let some = obj[arrPath[i]];

        // а вот теперь реализую как раз то, что крутилось в голове на нашей встрече,
        // а именно - вложенный цикл (здесь уже обращаемся ко второму элементу)
        for (let n = 1; n < 2; n++) {
            console.log( some[arrPath[n]] );
        }
    }
};

result(obj, arrPath);




// 2 вариант решения
const result2 = function (obj, path) {

  // мне все же ну очень захотелось попробовать реализовать без применения массивов, а через строку, которая дана изначально
    for (let word of path) {

        // соответственно, здесь появилась та же проблема, что при второй итерации мы получаем undefined, но
        // благо, что костыли никто не отменял ) Я поставил условие, что в случае возникновения undefined при попытке
        // обращения к значению объекта - просто пропускать данную итерацию. Сработало
        if (word === "." || obj[word] === undefined) {
            continue;

        } else {

            // опять же вводим новую переменную
            let some = obj[word];

            // и проходим по второму кругу по вложенному циклу
            for (word of path) {

                // здесь мы уже получим undefined на первой итерации, но ничего страшного - придуманное выше условие отрабатывает и здесь 
                if (word === "." || some[word] === undefined) {
                  continue;

                } else {

                  // здесь опять же, по условию задачи лучше писать return, но оставляю console.log - вдруг захотите проверить 
                  console.log(some[word]);
                }
            }
        }
    }
};

result2(obj, path);

// P.S. Пока писал второй вариант решения, подумал, что мне вот-вот позвонят из ГИТО и предложат стать их поставщиком костылей




// 3 вариант  - для любого уровня вложенности (и заодно, пожалуй, самый адекватный)
let obj2 = {
    a: {
        b: {
            c: {
                d: 1,
            },
        },
    },
};

const path2 = "a.b.c.d";

// Решение
let arrPath2 = path2.split(".");

const result3 = function (obj2, arrPath2) {
  
    for (let item of arrPath2) {

        // а ведь все решение заключалось лишь в том, чтобы результат текущей итерации присвоить переменной...
        obj2 = obj2[item];
    }
    console.log(obj2);
};

result3(obj2, arrPath2);




// 4 вариант - кстати, у меня в памяти есть, что Дмитрий (надеюсь, не ошибся в имени) на собеседовании просил эту же задачу решить через reduce.
// учитывая, что мы можем ее решить через цикл как в 3 варианте, через reduce это тоже не составит труда
let obj3 = {
    a: {
        b: {
            c: {
                d: 1,
            },
        },
    },
};

const path3 = "a.b.c.d";

// Решение
let arrPath3 = path3.split(".");

const result4 = function (obj3, arrPath3) {
  
    // стандартный метод reduce, когда в единую переменную для временных результатов (в данном случае это temp)
    // эффектом накопления передается результат действия над каждым элементом массива (а этот результат передается в следующую итерацию)
    let resultArr = arrPath3.reduce( (temp, item) => temp[item], obj3);
    console.log(resultArr); // соответственно, по классике - здесь return 
};

result4(obj3, arrPath3);

